{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>The mPython control board is a MicroPython microcontroller board that integrates the ESP32 high-performance dual-core chip and uses the most popular Python programming language so that you can easily transfer code from the computer to the control board and experience the endless fun of program creation!</p>"},{"location":"#technical-parameters","title":"Technical Parameters","text":"<p>The board has the following hardware features:</p> <p>ESP-32 master control Processor: Tensilica LX6 dual-core processor (one core handles high-speed connections; one core handles independent application development) Main frequency: up to 240MHz clock frequency SRAM: 520KB Flash\uff1a8MB Wi-Fi standards: FCC/CE/TELEC/KCC Wi-Fi protocol: 802.11 b/g/n/d/e/i/k/r (802.11n, speed up to 150 Mbps), A-MPDU and A-MSDU aggregation, support 0.4us guard interval Frequency range: 2.4~2.5 GHz Bluetooth protocol: Compliant with Bluetooth v4.2 BR/EDR and BLE standards Bluetooth audio: CVSD and SBC audio Low power consumption: 10uA Power supply mode: USB power supply; external power supply; Working voltage: 3.3V Maximum operating current: 200mA Maximum load current: 1000mA Take control of the board Three-axis accelerometer MSA300: Measuring range: \u00b12/4/8/16G; Six-axis sensor (v2.1.0 and later): QMI8658C (LGA-14) gyroscope: optional range, up to \u00b12048\u00b0/s Three-axis accelerometer: optional range, up to \u00b116G; Geomagnetic sensor MMC5983MA: Measuring range: \u00b18G range; accuracy 0.4mGs, electronic compass error \u00b10.5\u00b0; Geomagnetic sensor MMC5603NJ (v2.2.0 and later versions): 3-axis, minimum resolution is 0.0625mG, \u00b130G range, pointing accuracy within \u00b11\u00b0; Light sensor: Phototransistor ALS-PT19-315C Microphone: EM4013BTC1R16B-T0-423 3 full-color WS2812-2020 RGB-LED lamp beads 1.3-inch OLED display, supports 16*16 character display, resolution 128x64 Passive buzzer SMD-050020F-03040N Supports 2 physical buttons (A/B) and 6 touch buttons (P/Y/T/H/O/N) Supports 1-way alligator clip interface, which can easily connect to various resistive sensors  </p>"},{"location":"#expand-interface","title":"Expand interface","text":"<p>20 channels of digital I/O, (supporting 12 channels of PWM and 6 channels of touch input) 5-channel 12-bit analog input ADC, P0~P4 1-way external input alligator clip interface: EXT/GND Support I2C communication protocol Support UART communication protocol Support SPI communication protocol  </p>"},{"location":"advancedtutorial/","title":"Advanced Tutorial","text":""},{"location":"advancedtutorial/#1-random-numbers","title":"1. Random Numbers","text":"<p>Sometimes we need to do something random or generate random numbers. At this time, you can use the <code>random</code> module.</p> <p>For example, here's how to randomly display names on an OLED display:</p> <pre><code>from mpython import *\nimport random\n\nnames = [\"Mary\", \"Yolanda\", \"Damien\", \"Alia\", \"Kushal\", \"Mei Xiu\", \"Zoltan\"]\n\noled.DispChar(random.choice(names), 40, 20)\noled.show()\noled.fill(0)\n</code></pre> <p>The list (names) contains seven names defined as strings. The random.choice method takes a list of names as a parameter and returns a randomly selected item.</p> <p>Can you modify the list to include your own name?</p>"},{"location":"advancedtutorial/#11-display-numbers-randomly","title":"1.1. Display Numbers Randomly","text":"<p>Random numbers are very useful. They are very common in the game. Why do we still have dice?</p> <p>MicroPython comes with several useful random number methods. Here's how to make a simple dice:</p> <pre><code>from mpython import *\nimport random\n\noled.DispChar(str(random.randint(1, 6)), 60, 20)\noled.show()\noled.fill(0)\n</code></pre> <p>Every time the dashboard is restarted, it will display a number between 1 and 6. randint() returns an integer, we need to use str() to convert the integer into a string (for example, 6 -&gt; \"6\"). oled.DispChar() writes random numbers to oled.</p> <p>If you want to set a random range or increasing base, you can use random.randrange():</p> <pre><code>from mpython import *\nimport random\n\noled.DispChar(str(random.randrange(0, 10, 2)), 60, 20)\noled.show()\noled.fill(0)\n</code></pre> <p>random.randrange(start, end, step). start is the starting value of the random number, end is the ending value of the random number, and step is the increasing base. The above example randomly displays even numbers in the range (0,10).</p> <p>Sometimes you need numbers with decimal points. You can use random.random() to generate a random floating point number from 0.0 to 1.0. If you need the result of adding larger random floating point numbers use random.uniform():</p> <pre><code>from mpython import *\nimport random\n\noled.DispChar(str(random.random()), 30, 10)\noled.DispChar(str(random.uniform(1, 20)), 30, 30)\noled.show()\noled.fill(0)\n</code></pre>"},{"location":"advancedtutorial/#12-random-seeds","title":"1.2. Random Seeds","text":"<p>The random number in MicroPython is actually a stable sequence of results obtained by a stable algorithm, not a random sequence. The seed is the first value that the algorithm starts calculating. So it will appear that as long as the seed is the same, all subsequent \"random\" results and sequences will be exactly the same.</p> <p>Specify a random number seed, usually used in conjunction with other random number generation functions</p> <p>Sometimes you want to have repeatable random behavior: a reproducible source of randomness. It's like saying you need the same five random values every time you roll a die.</p> <p>Example:</p> <pre><code>import random\nfrom mpython import *\n\nfor i in range(0, 2):\n    random.seed(8)\n\n    for j in range(8):\n        oled.DispChar(str(random.randint(1, 10)), j * 16, i * 16)\n        oled.show()\n        print(random.randint(1, 10))\n\noled.fill(0)\n</code></pre>"},{"location":"advancedtutorial/#13-falling-snow-effect","title":"1.3. Falling Snow Effect","text":"<p>Combined with the random number generation learned above, we can use the control panel OLED screen to create the effect of falling snowflakes.</p> <pre><code>from mpython import *\nfrom random import randint\n\nclass snow():\n    def __init__(self):                \n        self.x = randint(0, 127)         # Randomly generate the starting coordinate point of the snowflake\n        self.y = randint(0, 10)\n        self.r = randint(1, 2)           # Randomly generate the size of the snowflake radius\n        self.vx = randint(-2, 2)         # Randomly generate the x,y movement path of the snowflake\n        self.vy = randint(1, 3)         \n\n    def refresh(self):                 \n        self.x += self.vx               # Move the coordinate down, snowflake falls\n        self.y += self.vy\n        if self.x &gt; 128 or self.x &lt; 0:\n            self.x = randint(0, 127)\n        if self.y &gt; 63 or self.y &lt; 0:\n            self.y = 0\n\n    def run(self):\n        self.refresh()\n        oled.fill_circle(self.x, self.y, self.r, 1)     # Draw the snowflake\nballs = []\nfor x in range(20):              # Generate 20 snowflake points\n    balls.append(snow())        \nwhile True:\n    sleep_ms(50)                 # Refresh time\n    oled.fill(0)                 # Clear the screen\n    for b in balls:              # Snowflake falls\n        b.run()\n    oled.show()                  # Display OLED\n</code></pre>"},{"location":"advancedtutorial/#2-save","title":"2. Save","text":"<p>Sometimes you need to store useful information. This information is stored as data: a representation of the information (in digital form when stored on a computer). If you store data on your computer, it should remain even if you turn the device off and on again.</p> <p>The microPython bit allows you to do this using a very simple file system.</p>"},{"location":"advancedtutorial/#what-is-a-file-system","title":"What is a file system?","text":"<p>It is a method of storing and organizing data in a persistent manner - any data stored in the file system should survive device restarts. As the name suggests, data stored in a file system is organized into files.</p> <p>Computer files are named digital resources stored on a file system. These resources contain useful information as data. This is exactly how paper documents work. It is a named container that contains useful information. Often, paper and digital files are named to indicate what they contain. On computers, files are usually ended with a suffix like <code>.txt</code> for text files, <code>.jpg</code> for JPEG images, and <code>.mp3</code> for sound data encoded as MP3.</p> <p>Some file systems, such as those on your laptop or PC, allow you to organize files into directories: named containers that group related files and subdirectories together. However, the file system provided by MicroPython is a flat file system. Flat file systems have no directories - all files are stored in just one place.</p> <p>The Python programming language contains an easy-to-use and powerful way to work with your computer's file system. MicroPython on mPython implements a useful subset of these features, making it easy to read and write files on the device, while also providing consistency with other Python versions.</p>"},{"location":"advancedtutorial/#21-open-the-file","title":"2.1. Open the file","text":"<p>The following are relevant operation instructions for Python File operations.</p> <pre><code>open(path+filename, mode), e.g., f = open('/tmp/hello', 'w')\n</code></pre>"},{"location":"gettingstarted/","title":"Getting Started","text":""},{"location":"gettingstarted/#getting-started","title":"Getting Started","text":""}]}