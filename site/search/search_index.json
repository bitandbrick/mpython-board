{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>The mPython control board is a MicroPython microcontroller board that integrates the ESP32 high-performance dual-core chip and uses the most popular Python programming language so that you can easily transfer code from the computer to the control board and experience the endless fun of program creation!</p>"},{"location":"#technical-parameters","title":"Technical Parameters","text":"<p>The board has the following hardware features:</p> <p>ESP-32 master control Processor: Tensilica LX6 dual-core processor (one core handles high-speed connections; one core handles independent application development) Main frequency: up to 240MHz clock frequency SRAM: 520KB Flash\uff1a8MB Wi-Fi standards: FCC/CE/TELEC/KCC Wi-Fi protocol: 802.11 b/g/n/d/e/i/k/r (802.11n, speed up to 150 Mbps), A-MPDU and A-MSDU aggregation, support 0.4us guard interval Frequency range: 2.4~2.5 GHz Bluetooth protocol: Compliant with Bluetooth v4.2 BR/EDR and BLE standards Bluetooth audio: CVSD and SBC audio Low power consumption: 10uA Power supply mode: USB power supply; external power supply; Working voltage: 3.3V Maximum operating current: 200mA Maximum load current: 1000mA Take control of the board Three-axis accelerometer MSA300: Measuring range: \u00b12/4/8/16G; Six-axis sensor (v2.1.0 and later): QMI8658C (LGA-14) gyroscope: optional range, up to \u00b12048\u00b0/s Three-axis accelerometer: optional range, up to \u00b116G; Geomagnetic sensor MMC5983MA: Measuring range: \u00b18G range; accuracy 0.4mGs, electronic compass error \u00b10.5\u00b0; Geomagnetic sensor MMC5603NJ (v2.2.0 and later versions): 3-axis, minimum resolution is 0.0625mG, \u00b130G range, pointing accuracy within \u00b11\u00b0; Light sensor: Phototransistor ALS-PT19-315C Microphone: EM4013BTC1R16B-T0-423 3 full-color WS2812-2020 RGB-LED lamp beads 1.3-inch OLED display, supports 16*16 character display, resolution 128x64 Passive buzzer SMD-050020F-03040N Supports 2 physical buttons (A/B) and 6 touch buttons (P/Y/T/H/O/N) Supports 1-way alligator clip interface, which can easily connect to various resistive sensors  </p>"},{"location":"#expand-interface","title":"Expand interface","text":"<p>20 channels of digital I/O, (supporting 12 channels of PWM and 6 channels of touch input) 5-channel 12-bit analog input ADC, P0~P4 1-way external input alligator clip interface: EXT/GND Support I2C communication protocol Support UART communication protocol Support SPI communication protocol  </p>"},{"location":"Introduction/","title":"Getting Started","text":"<p>1. Random numbers Sometimes we need to do something random or generate random numbers. At this time you can use the random module. For example, here's how to randomly display names on an OLED display: from mpython import * import random names = [\"Mary\", \"Yolanda\", \"Damien\", \"Alia\", \"Kushal\", \"Mei Xiu\", \"Zoltan\" ] oled.DispChar(random.choice(names),40,20) oled.show() oled.fill(0) The list (names) contains seven names defined as strings. The random.choice method takes a list of names as a parameter and returns a randomly selected item. Can you modify the list to include your own name? 1.1.Display numbers randomly Random numbers are very useful. They are very common in the game. Why do we still have dice? MicroPython comes with several useful random number methods. Here's how to make a simple dice: from mpython import * import random oled.DispChar(str(random.randint(1,6)),60,20) oled.show() oled.fill(0) annotation Every time the dashboard is restarted, it will display a number between 1 and 6. randint()What is returned is an integer, we need to use str()to convert the integer into a string (for example, 6 -&gt; \"6\"). oled.DispChar()Write random numbers to oled. If you want to set a random range or increasing base, you can use random.randrange(): from mpython import * import random oled.DispChar(str(random.randrange(0,10,2)),60,20) oled.show() oled.fill(0) annotation random.randrange(start, end, step). startis the starting value of the random number, endis the ending value of the random number, and step is the increasing base. The above example randomly displays even numbers in the range (0,10). Sometimes you need numbers with decimal points. You can use random.randomthe method to generate a random floating point number from 0.0 to 1.0. If you need the result of adding larger random floating point numbersrandom.uniform from mpython import * import random oled.DispChar(str(random.random()),30,10) oled.DispChar(str(random.uniform(1,20)),30,30) oled.show() oled.fill(0) 1.2. Random seeds The random number in MicroPython is actually a stable sequence of results obtained by a stable algorithm, not a random sequence. The seed is the first value that the algorithm starts calculating. So it will appear that as long as the seed is the same, all subsequent \"random\" results and sequences will be exactly the same. Specify a random number seed, usually used in conjunction with other random number generation functions Sometimes you want to have repeatable random behavior: a reproducible source of randomness. It's like saying you need the same five random values \u200b\u200bevery time you roll a die. Example: import random from mpython import * for i in range(0,2): random.seed(8) for j in range(8): oled.DispChar(str(random.randint(1,10)),j*16,i*16) oled.show() print(random.randint(1,10)) oled.fill(0) 1.3. Falling snow effect Combined with the random number generation learned above, we can use the control panel OLED screen to create the effect of falling snowflakes. 1 2# \u4f7f\u7528random\u968f\u673a\u751f\u6210\u98d8\u96ea\u6548\u679c 3 4from mpython import * 5from random import randint 6 7class snow(): 8 def __init__(self): 9 self.x = randint(0,127) #\u968f\u673a\u751f\u6210\u96ea\u82b1\u7684\u8d77\u59cb\u5750\u6807\u70b9 10 self.y = randint(0,10) 11 self.r = randint(1,2) #\u968f\u673a\u751f\u6210\u96ea\u82b1\u7684\u534a\u5f84\u5927\u5c0f 12 self.vx = randint(-2,2) #\u968f\u673a\u751f\u6210\u96ea\u82b1\u7684x,y\u79fb\u52a8\u8def\u5f84 13 self.vy = randint(1,3) 14 15 def refresh(self): 16 self.x += self.vx #\u4e0b\u79fb\u5750\u6807\uff0c\u96ea\u82b1\u843d\u4e0b 17 self.y += self.vy 18 if self.x &gt; 128 or self.x &lt; 0: 19 self.x = randint(0,127) 20 if self.y &gt; 63 or self.y &lt; 0: 21 self.y = 0 22 23 def run(self): 24 self.refresh() 25 oled.fill_circle(self.x,self.y,self.r,1) #\u753b\u96ea\u82b1 26 27balls = [] 28for x in range(20): #\u751f\u621020\u4e2a\u96ea\u82b1\u70b9 29 balls.append(snow()) 30 31while True: 32 sleep_ms(50) #\u5237\u65b0\u65f6\u95f4 33 oled.fill(0) #\u6e05\u5c4f 34 for b in balls: #\u96ea\u82b1\u843d\u4e0b 35 b.run() 36 oled.show() #\u663e\u793aoled 37 38</p>"}]}